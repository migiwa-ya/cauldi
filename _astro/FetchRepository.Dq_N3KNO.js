import{j as I}from"./jsx-runtime.D_zvdyIk.js";import{r as T}from"./index.Dy6lLLXr.js";import{s as E,a as J}from"./_slug_.1673099a.rcQGyw0O.js";function K(l,e="Y-m-d H:i:s"){const t=l instanceof Date?l:new Date(l),r=s=>String(s).padStart(2,"0"),n={Y:t.getFullYear(),m:r(t.getMonth()+1),d:r(t.getDate()),H:r(t.getHours()),i:r(t.getMinutes()),s:r(t.getSeconds())};return e.replace(/[YmdHis]/g,s=>n[s]??s)}const ye=({item:l})=>{const e=l.link;return I.jsxs("a",{href:e,className:E.card,children:[I.jsx("div",{className:E.date,children:I.jsxs("time",{dateTime:K(l.updatedAt),children:[I.jsx("span",{children:K(l.updatedAt,"m")}),I.jsx("span",{children:K(l.updatedAt,"d")})]})}),I.jsx("h2",{children:l.displayName}),I.jsx("div",{className:E.content,children:l.images.map(({path:t,label:r})=>I.jsxs("figure",{children:[I.jsx("img",{src:t,alt:r,width:"350",height:"525",loading:"lazy"}),I.jsx("figcaption",{children:r})]},t))}),I.jsx("strong",{children:"基本情報"}),I.jsx("p",{className:"clamp-3",children:l.content})]})},X=({loading:l=!1})=>l?I.jsx("div",{className:J.loadingFooter,children:I.jsx("div",{className:J.spinner})}):null;function xe({items:l,loadMore:e,hasMore:t,ItemComponent:r}){const n=T.useRef(null),[s,o]=T.useState(!1),a=T.useCallback(i=>{n.current&&n.current.disconnect(),n.current=new IntersectionObserver(c=>{c[0].isIntersecting&&t&&!s&&(o(!0),Promise.resolve(e()).finally(()=>{o(!1)}))}),i&&n.current.observe(i)},[e,t,s]);return I.jsxs(I.Fragment,{children:[l.map((i,c)=>I.jsx(r,{item:i},i.key)),I.jsx("div",{ref:a}),I.jsx(X,{loading:s&&t})]})}function F(l,e){const t=e.split(".");let r=[l];for(const n of t)r=r.map(s=>Array.isArray(s)?s.map(o=>o?.[n]):s?.[n]).flat().filter(s=>s!=null);return r.flat(1/0).filter(n=>n!=null).map(n=>String(n))}function A(l,e){const t=new Map;for(const r of l){const n=F(r,e);for(const s of n)t.has(s)||t.set(s,[]),t.get(s).push(r)}return t}function Z(l,e,t){const r=n=>n.includes(e);return Array.from(l.entries()).filter(([n])=>n&&r(n)).map(([,n])=>n)}function V(l,e,t,r){const n=r??A(t,e.foreignKey),s=e.type,o=F(l,e.localKey).flat();let a=[];if(o.length===1)for(const i of o){const c=n.get(i);c&&a.push(...c)}else a=o.map(i=>Z(n,i)).flat().flat();return s==="hasOne"?a.length>0?a[0]:null:a}function W(l,e,t,r,n,s){const o=F(l,e.sourceLocalKey).flat(),a=s??A(t,e.throughForeignKey),i=n??A(r,e.targetForeignKey),f=o.map(h=>a.get(h)).filter(h=>!!h).filter(Boolean).flat().map(h=>F(h,e.throughLocalKey).filter(u=>!!u).flat().map(u=>i.get(u)).filter(u=>!!u).flat()).flat();return e.type==="hasOneThrough"?f.length>0?f[0]:null:f}function B(l){const e=ee(l);return e.substring(0,e.lastIndexOf("/"))}function ee(l){for(;l.endsWith("/");)l=l.slice(0,-1);return l}function j(...l){return l.join("/").replace(/\/+/g,"/")}function R(...l){return j(...l,"_index.jsonl")}function M(...l){return j(...l,"_prefixes.jsonl")}function k(l){const e=l.split("/"),t=e.length;return{base:j(...e.slice(0,t-1)),tail:e[t-1]}}async function*C(l,e){let t="";for(;;){const{done:r,value:n}=await l.read();if(r)break;t+=e.decode(n,{stream:!0});let s=t.split(`
`);t=s.pop()??"";for(const o of s)o.trim()&&(yield JSON.parse(o))}t.trim()&&(yield JSON.parse(t))}async function*D(l,e){let t="";for(;;){const{done:r,value:n}=await l.read();if(r)break;t+=e.decode(n,{stream:!0});let s=t.split(`
`);t=s.pop()??"";for(const o of s)o.trim()&&(yield o)}t.trim()&&(yield t)}function q(l){return Array.isArray(l)?l:[l]}function $(l){if(l instanceof Map){const e={};for(const[t,r]of l.entries())e[t]=$(r);return e}else{if(l instanceof Set)return Array.from(l).map($);if(Array.isArray(l))return l.map($);if(typeof l=="object"&&l!==null){const e={};for(const t of Object.keys(l))e[t]=$(l[t]);return e}else return l}}function te(l){return l.split(`
`).map(e=>e.trim()).filter(Boolean)}function se(l,e,t,r,n,s){let o=!1,a=!1;if(n==="after")o=t+(t>0?1:0)+e<r,a=t+(t>0?1:0)>0;else{const i=t,c=Math.max(0,i-e);o=i<r,a=c>0}return{hasNextPage:o,hasPreviousPage:a,startCursor:l.length>0?s(l[0]):void 0,endCursor:l.length>0?s(l[l.length-1]):void 0}}function re(l,e,t,r){if(r==="after")return l.slice(e+(e>0?1:0),e+(e>0?1:0)+t);{const n=e,s=Math.max(0,n-t);return l.slice(s,n)}}function ne(l){const e=JSON.stringify(l),t=new TextEncoder().encode(e);let r="";for(let n of t)r+=String.fromCharCode(n);return btoa(r)}function N(l){try{const e=atob(l),t=Uint8Array.from(e,n=>n.charCodeAt(0));return JSON.parse(new TextDecoder().decode(t))}catch{throw new Error("Invalid cursor")}}function _(l,e,t){return async function*(...r){const n=e(...r);if(await t.has(n))for(const s of await t.get(n))yield s;else{const s=[];for await(const o of l(...r))s.push(o),yield o;t.set(n,s)}}}class Y{constructor(){this.cache=new Map}async get(e){return this.cache.get(e)}async set(e,t){this.cache.set(e,t)}async has(e){return this.cache.has(e)}async delete(e){this.cache.delete(e)}async clear(){this.cache.clear()}}class O{constructor(e,t,r,n,s){this.sourceLoader=e,this.repository=t,this.resolver=r,this.logger=n,this.customIndexers={},this.cache=new Y,s&&(this.customIndexers=s)}async save(){for(const e of this.resolver.resolveAll()){if(!e.indexes)continue;const t=await this.buildRecords(e),r=this.getPrefixIndexPathByResolvedRecords(t,e.indexes),n=this.createIndexLines(t,r,e);for await(const[s,o]of Array.from(n))for(const[a,i]of o){const c=i.sort(this.indexSort()).map(f=>JSON.stringify(f)).join(`
`);this.repository.writeFile(s,c)}for await(const[s,o]of this.collectPrefixDirs(r,e).entries())for(const[a,i]of o){const c=[...i].join(`
`);this.repository.writeFile(a,c)}}}async updateIndexesForFiles(e){const t=new Map,r=[];for(const i of e)if(i.status==="A"||i.status==="D"){t.has(i.source)||t.set(i.source,new Map);const c=t.get(i.source);c?.has(i.status)||c?.set(i.status,new Set),c?.get(i.status)?.add({slug:i.slug})}const n=new Map;for(const i of e)n.has(i.source)||n.set(i.source,new Map),n.get(i.source).set(i.slug,i);const s=new Map;for(const[i,c]of t.entries()){const f=this.resolver.resolveOne(i);if(!f.indexes)continue;const h=c.get("A")??new Set;(c.get("M")??new Set).forEach(x=>h.add(x));const g=c.get("D")??new Set,u=[...h].map(x=>x.slug),d=await this.sourceLoader.loadBySlugs(i,u);s.has(f.name)||s.set(f.name,new Set),d.forEach(x=>s.get(f.name).add(x));const y=new Set(d.map(x=>x.slug));for(const x of u){if(y.has(x))continue;const p=n.get(i).get(x);p&&s.get(f.name).add(o(p))}for(const{slug:x}of g){const p=n.get(i).get(x);p&&s.get(f.name).add(o(p))}}function o(i){return{slug:i.slug,...i.fields}}const a={};for(const[i,c]of s){const f=this.resolver.resolveOne(i),h=f.relations??[];for(const[g,u]of Object.entries(h))if(this.isThroughRelation(u)){if(!s.get(u.to)){let d=s.get(u.through);if(!d){const x=(await Promise.all([...c].map(w=>this.findIndexLines(u.through,u.throughForeignKey,w[u.sourceLocalKey])))).flat().filter(w=>!!w);if(!x||!x.length)throw new Error;const p=x.map(w=>Object.keys(w?.ref)).flat();if(d=new Set(await this.sourceLoader.loadBySlugs(u.through,p)),!d.size)throw new Error(`[${f.name}] is trying to relate to a non-existent [${u.to}] source, or there is an inconsistency in the index. Please check and correct the existence of the difference file and source file, or rebuild the index.`);s.set(u.through,d)}let y=s.get(u.to);if(!y){const p=(await Promise.all([...d].map(w=>this.findIndexLines(u.to,u.targetForeignKey,w[u.throughLocalKey])))).flat().filter(w=>!!w).map(w=>Object.keys(w?.ref)).flat();if(y=new Set(await this.sourceLoader.loadBySlugs(u.to,p)),!y.size)throw new Error(`[${f.name}] is trying to relate to a non-existent [${u.to}] source, or there is an inconsistency in the index. Please check and correct the existence of the difference file and source file, or rebuild the index.`);s.set(u.to,y)}}a[g]={targetMap:A([...s.get(u.to)],u.targetForeignKey),throughMap:A([...s.get(u.through)],u.throughForeignKey)}}else{if(!s.get(u.to)){const d=[...c].map(w=>F(w,u.localKey)).flat(),x=(await Promise.all(d.map(w=>this.findIndexLines(u.to,u.foreignKey,w)))).flat().filter(w=>!!w).map(w=>Object.keys(w?.ref)).flat(),p=new Set(await this.sourceLoader.loadBySlugs(u.to,x));if(!p.size)throw new Error(`[${f.name}] is trying to relate to a non-existent [${u.to}] source, or there is an inconsistency in the index. Please check and correct the existence of the difference file and source file, or rebuild the index.`);s.set(u.to,p)}a[g]={foreignMap:A([...s.get(u.to)],u.foreignKey)}}}for(const[i,c]of t.entries()){const f=this.resolver.resolveOne(i),h=f.relations??[];if(!f.indexes||!h)continue;const g=[...s.get(f.name)].map(y=>{const x={...y};for(const[p,w]of Object.entries(h))this.isThroughRelation(w)?x[p]=W(y,w,[...s.get(w.through)],[...s.get(w.to)],a[p].targetMap,a[p].throughMap):x[p]=V(y,w,[...s.get(w.to)],a[p].foreignMap);return x}),u=this.getPrefixIndexPathByResolvedRecords(g,f.indexes),d=this.createIndexLines(g,u,f,t);for await(const[y,x]of Array.from(d)){let p=new Set;if(await this.repository.exists(y)){const w=await this.repository.readFile(y);p=new Set(w.split(`
`).map(v=>JSON.parse(v)))}for(const[w,v]of x)for(const m of v){if(w==="A"){const b=[...p].find(P=>P.v===m.v&&P.vs===m.vs);b?b.ref={...b.ref,...m.ref}:p.add(m)}else if(w==="D"){const b=[...p].find(P=>P.v===m.v&&P.vs===m.vs);b&&p.delete(b)}const S=[...p].sort(this.indexSort()).map(b=>JSON.stringify(b)).join(`
`);S.length?(this.repository.writeFile(y,S),r.push(y)):(this.repository.removeDir(B(y)),r.push(y))}}for await(const[y,x]of this.collectPrefixDirs(u,f,t).entries())for(const[p,w]of x)if(await this.repository.exists(p)){if(y==="A")if(await this.repository.exists(p)){const v=await this.repository.readFile(p),m=new Set(v.split(`
`).map(b=>b));for(const b of w)m.add(b);const S=[...m].sort((b,P)=>b.localeCompare(P)).map(b=>b).join(`
`);this.repository.writeFile(p,S),r.push(p)}else{const v=[...w].sort((m,S)=>m.localeCompare(S)).map(m=>m).join(`
`);this.repository.writeFile(p,v),r.push(p)}else if(y==="D"){const v=await this.repository.readFile(p),m=new Set(v.split(`
`).map(S=>S));for(const S of[...w]){const b=j(B(p),S);await this.repository.exists(b)||m.has(S)&&m.delete(S)}if(m.size===0)await this.repository.removeDir(B(p)),r.push(p);else{const S=[...m].join(`
`);await this.repository.writeFile(p,S),r.push(p)}}}}return r}async*readForwardPrefixIndexLines(e,t=20,r,n="slug",s=!1){const o=r?N(r):void 0,a=o?j(e,o.order[n]):s?k(await this.findLastIndexPath(e)).base:k(await this.findFirstIndexPath(e)).base,i=o?.slug;let c=0,f=!i;const h=s?this.walkPrefixIndexesUpword:this.walkPrefixIndexesDownword,g=_(d=>h.bind(this)(d),d=>d,this.cache),u=s;for await(const d of g(a))for await(const y of this.readIndexFileLines(d,u)){if(!f&&i&&Object.prototype.hasOwnProperty.call(y.ref,i)){f=!0;continue}if(f&&(yield y,++c>=t))return}}async*readBackwardPrefixIndexLines(e,t=20,r,n="slug",s=!1){const o=r?N(r):void 0,a=o?j(e,o.order[n]):s?k(await this.findFirstIndexPath(e)).base:k(await this.findLastIndexPath(e)).base,i=o?.slug;let c=0,f=!i;const h=s?this.walkPrefixIndexesDownword:this.walkPrefixIndexesUpword,g=_(d=>h.bind(this)(d),d=>d,this.cache),u=!s;for await(const d of g(a))for await(const y of this.readIndexFileLines(d,u)){if(!f&&i&&Object.prototype.hasOwnProperty.call(y.ref,i)){f=!0;continue}if(f&&(yield y,++c>=t))return}}async*readIndexFileLines(e,t){const n=(await this.repository.openFileStream(e)).getReader(),s=new TextDecoder;if(t){const o=[];for await(const a of C(n,s))o.push(a);yield*o.reverse()}else yield*C(n,s)}async findFirstIndexPath(e){const t=M(e);let r,n;try{n=await this.repository.openFileStream(t);const s=n.getReader(),o=new TextDecoder,{value:a}=await D(s,o).next();r=a}catch{return R(e)}return this.findFirstIndexPath(j(e,r))}async findLastIndexPath(e){const t=M(e);let r="",n;try{n=await this.repository.openFileStream(t);const s=n.getReader(),o=new TextDecoder;for await(r of D(s,o));}catch{return R(e)}return this.findLastIndexPath(j(e,r))}async*walkPrefixIndexesDownword(e){const t=this.repository;let r=!1;const n=async function*(s,o=new Set){if(!o.has(M(s)))try{const i=(await t.openFileStream(M(s))).getReader(),c=new TextDecoder;o.add(M(s)),o.add(s);for await(let f of D(i,c))!r&&o.has(j(s,f))&&(r=!0),r&&(yield*n(j(s,f),o))}catch{o.add(s)}if(!o.has(R(s)))try{await t.readFile(R(s)),yield R(s),o.add(R(s)),o.add(s)}catch{o.add(s)}o.has(k(s).base)||(r=!1,yield*n(k(s).base,o))};yield*n(e,new Set)}async*walkPrefixIndexesUpword(e){const t=this.repository;let r=!1;const n=async function*(s,o=new Set){if(!o.has(M(s)))try{const i=(await t.openFileStream(M(s))).getReader(),c=new TextDecoder,f=new Set;o.add(M(s)),o.add(s);for await(const h of D(i,c))f.add(h);for(const h of[...f].reverse())!r&&o.has(j(s,h))&&(r=!0),r&&(yield*n(j(s,h),o))}catch{o.add(s)}if(!o.has(R(s)))try{await t.readFile(R(s)),yield R(s),o.add(R(s)),o.add(s)}catch{o.add(s)}o.has(k(s).base)||(r=!1,yield*n(k(s).base,o))};yield*n(e,new Set)}flatPrefixIndexLine(e){const t=new Set,r=[];for(const n of e)for(const[s,o]of Object.entries(n.ref))t.has(s)||(t.add(s),r.push({v:n.v,vs:n.vs,ref:{[s]:o}}));return r}getPrefixIndexPath(e,t){const r=[...e].slice(0,t).map(n=>n.charCodeAt(0).toString(16).padStart(4,"0"));return j(...r)}async buildRecords(e){const t=e.relations??{},r=new Set([e.name]);for(const i of Object.values(t))this.isThroughRelation(i)&&r.add(i.through),r.add(i.to);const n=await Promise.all(Array.from(r).map(i=>this.sourceLoader.loadBySourceName(i))),s=Array.from(r).reduce((i,c,f)=>(i[c]=n[f],i),{}),o={};for(const[i,c]of Object.entries(t))this.isThroughRelation(c)?o[i]={targetMap:A(s[c.to],c.targetForeignKey),throughMap:A(s[c.through],c.throughForeignKey)}:o[i]={foreignMap:A(s[c.to],c.foreignKey)};return s[e.name].map(i=>{const c={...i};for(const[f,h]of Object.entries(t))this.isThroughRelation(h)?c[f]=W(i,h,s[h.through],s[h.to],o[f].targetMap,o[f].throughMap):c[f]=V(i,h,s[h.to],o[f].foreignMap);return c})}getPrefixIndexPathByResolvedRecords(e,t){const r=Array.from(new Set(Object.keys(t))),n=new Map;for(const s of e){const o=new Map;for(const a of r){const i=F(s,a);for(const c of i){const f=this.getPrefixIndexPath(c,t[a].depth);o.get(a)||o.set(a,new Set),o.get(a)?.add(f)}}n.set(s.slug,o)}return n}createIndexLines(e,t,r,n){if(!r.indexes)return[];const s=Object.keys(r.indexes),o=e.map(c=>this.extractIndexField(c,r)),a=new Map;for(const c of o){a.has(c.slug)||a.set(c.slug,new Map);const f=a.get(c.slug);for(const h of s){f.has(h)||f.set(h,new Map);const g=f.get(h),u=c.values.get(h);if(u)for(const{value:d,refSlug:y}of u){const x=Array.isArray(d)?d:[d];for(const p of x)g.has(p)||g.set(p,new Map),g.get(p).set(y,!0)}}}const i=new Map;for(const[c,f]of a)for(const[h,g]of f)for(const[u,d]of g)for(const[y]of d){const x=r.indexes[h],p=this.getPrefixIndexPath(u,x.depth),w=R(x.dir,p),v=n?this.getStatus(n,r.name,c):"A",m={v:u,vs:y,ref:$(new Map([[c,t.get(c)]]))};i.has(w)||i.set(w,new Map);const S=i.get(w);S.has(v)||S.set(v,[]),S.get(v).push(m)}return i}collectPrefixDirs(e,t,r){const n=new Map;if(!t.indexes)throw new Error("");for(const[o,a]of e.entries()){const i=r?this.getStatus(r,t.name,o):"A";for(const[c,f]of a.entries()){const h=t.indexes[c];for(const g of f){const u=g.split("/");let d=h.dir;for(let y=0;y<u.length;y++){const x=u[y];n.has(i)||n.set(i,new Map);const p=n.get(i);p.has(d)||p.set(d,new Set),p.get(d).add(x),d+=x+"/"}}}}const s=new Map;for(const[o,a]of n.entries()){const i=new Map(Array.from(a).reverse()),c=new Map;for(const[f,h]of i.entries())c.set(M(f),new Set([...h].sort((g,u)=>g.localeCompare(u))));s.set(o,c)}return s}getStatus(e,t,r){const n=e.get(t);if(!n)throw new Error(`[${t}] is not found`);let s=null;for(const[o,a]of n.entries())for(const i of a)i.slug===r&&(s=o);if(!s)throw new Error(`[${t}] is not found`);return s}extractIndexField(e,t){const r=Object.keys(t.indexes??{}),n=new Map;for(const s of r){let o=F(e,s),a=new Array(o.length).fill(e.slug);const i=s.split(".").shift()??"";t.relations?.hasOwnProperty(i)&&(a=F(e,`${i}.slug`));for(let c=0;o.length>c;c++)(o[c]!=null||a[c]!=null)&&(n.has(s)||n.set(s,new Set),n.get(s)?.add({value:o[c],refSlug:a[c]}))}if(t.indexes&&this.customIndexers){for(const[s,o]of Object.entries(t.indexes))if(Object.prototype.hasOwnProperty.call(this.customIndexers,`${t.name}.${s}`))try{const a=this.customIndexers[`${t.name}.${s}`],i=a(e);if(i!=null){n.has(s)||n.set(s,new Set);const c=Array.isArray(i)?i:[i];for(const f of c)n.get(s)?.add({value:f,refSlug:e.slug})}}catch(a){this.logger?.warn?.(`[Indexer] Custom indexer for "${s}" threw error: ${a}`)}}return{slug:e.slug,values:n}}isThroughRelation(e){return typeof e=="object"&&"through"in e&&(e.type==="hasOneThrough"||e.type==="hasManyThrough")}static getIndexDir(e,t){return`${this.indexPrefix}/${e}.${t}/`}getIndexPath(e,t,r){const n=this.resolver.resolveOne(e);if(!n.indexes)return null;const s=n.indexes[t],o=this.getPrefixIndexPath(r,s.depth);return R(s.dir,o)}async findIndexLines(e,t,r,n=(s,o)=>s===o){const s=this.resolver.resolveOne(e);if(!s.indexes)return null;let o=this.getIndexPath(e,t,r);if(o&&s.indexes[t].depth>r.length&&(o=await this.findFirstIndexPath(k(o).base)),!o||!await this.repository.exists(o))return null;const a=this.repository,i=this.walkPrefixIndexesDownword,c=_(g=>i.bind(this)(g),g=>g,this.cache),f=new Set;let h=null;e:for await(const g of c(k(o).base))try{const d=(await a.openFileStream(g)).getReader(),y=new TextDecoder;for await(const x of C(d,y))if(n(x.v,r)?(f.add(x),h=!0):h===!0&&(h=!1),h===!1){await d.cancel();break e}if(!f.size)break}catch{break e}return this.flatPrefixIndexLine([...f])}indexSort(e=["v","vs"]){return(t,r)=>{for(const n of e){const s=t[n],o=r[n];if(typeof s=="string"&&typeof o=="string"){const a=s.localeCompare(o);if(a!==0)return a}else if(s!==o)return s<o?-1:1}return 0}}}O.indexPrefix="index";O.indexDepth=1;class L{constructor(e){this.sources=e,this.cache={}}resolveAll(){if(Object.values(this.cache).length!==0)return Object.values(this.cache);for(const[e]of Object.entries(this.sources))this.cache[e]=this.resolveOne(e);return Object.values(this.cache)}resolveOne(e){if(this.cache[e])return this.cache[e];const t=this.sources[e];if(!t)throw new Error(`Source not found: ${e}`);const r={slug:{dir:O.getIndexDir(e,"slug"),depth:O.indexDepth}};if(t.index)for(const[o,a]of Object.entries(t.index)){const i=a.indexDepth??O.indexDepth;if(!this.isDepthInRange(i))throw new Error("");r[o]={dir:O.getIndexDir(e,o),depth:i}}const n=[...Object.entries(this.sources).filter(([o])=>o!==e).map(([o,a])=>Object.entries(a.relations??{}).find(([i,c])=>this.isThroughRelation(c)?c.to===e||c.through===e:c.to===e)).filter(Boolean).filter(o=>!!o),...Object.entries(t.relations??{})];if(n)for(const[o,a]of n){const i=[];if(a.type==="belongsTo"||a.type==="belongsToMany"||a.type==="hasOne"||a.type==="hasMany"?a.to===e?i.push(a.foreignKey==="slug"?null:a.foreignKey):i.push(a.localKey==="slug"?null:a.localKey):(a.type==="hasOneThrough"||a.type==="hasManyThrough")&&(a.to===e?i.push(a.throughForeignKey==="slug"?null:a.throughForeignKey):i.push(a.targetForeignKey==="slug"?null:a.targetForeignKey)),!!i.length)for(const c of i)c&&(r[c]={dir:O.getIndexDir(e,c),depth:O.indexDepth})}if(t.customIndex)for(const[o,a]of Object.entries(t.customIndex)){const i=a.indexDepth??O.indexDepth;if(!this.isDepthInRange(i))throw new Error("");r[o]={dir:O.getIndexDir(e,o),depth:i}}const s={name:e,pattern:t.pattern,type:t.type,schema:t.schema,relations:t.relations,indexes:r};return this.cache[e]=s,s}isThroughRelation(e){return typeof e=="object"&&"through"in e&&(e.type==="hasOneThrough"||e.type==="hasManyThrough")}isDepthInRange(e){return e>=1&&e<=10}static getSourcePathsBySlugs(e,t){const r=e.match(/\.(\w+)$/),n=r?"."+r[1]:"";let s=t;if(e.includes("*")){const o=e.indexOf("*");let a=e.slice(o);a=this.pathToSlug(a).replace(/\.[^\.]+$/,""),a=a.replace(/\*\*/g,"([\\w-]+(--)?)*").replace(/\*/g,"[\\w-]+");const i=new RegExp("^"+a+"$");s=t.filter(c=>i.test(c))}return s.map(o=>this.resolveFilePath(e,this.slugToPath(o)+n))}static slugToPath(e){return e.replace(/--/g,"/")}static pathToSlug(e){return e.replace(/\//g,"--")}static extractBaseDir(e){const t=e.split("/"),r=t.findIndex(n=>n.includes("*"));return r===-1?e:j(...t.slice(0,r))+"/"}static resolveFilePath(e,t){return this.extractBaseDir(e)+t}static getSlugFromPath(e,t){const r=t.slice(t.lastIndexOf("."))||"",n=this.extractBaseDir(e);let s=t.startsWith(n)?t.slice(n.length):t;return s.startsWith("/")&&(s=s.slice(1)),this.pathToSlug(s.replace(r,""))}static patternTest(e,t){return this.globToRegExp(e).test(t)}static globToRegExp(e){const t=e.replace(/\\/g,"/");let r="^",n=0;for(;n<t.length;){const s=t[n];if(s==="*")if(t[n+1]==="*"){n++;const o=t[n+1]==="/";o&&n++,r+=o?"(?:[^/]+/)*":"(?:[^/]+/)*[^/]*"}else r+="[^/]*";else r+=s.replace(/[$^+.()|{}]/g,"\\$&");n++}return r+="$",new RegExp(r)}}function Q({rawContent:l}){const e=l.replace(/\r\n/g,`
`).split(`
`);let t=0;for(;t<e.length&&(!e[t].trim()||e[t].trim().startsWith("#"));)t++;if(e[t]&&e[t].trim().startsWith("- "))return n(0);function r(a=0){const i={};let c=null;for(;t<e.length;){let f=e[t];if(!f.trim()||f.trim().startsWith("#")){t++;continue}const h=f.match(/^(\s*)/)[1].length;if(h<a)break;if(f.includes(":")){const[g,...u]=f.split(":");let d=u.join(":").trim();if(t++,d.startsWith("[")&&!d.endsWith("]")){let p=[d];for(;t<e.length;){const w=e[t].trim();if(p.push(w),t++,w.endsWith("]"))break}d=p.join(" ").replace(/\s+/g," ")}const y=e[t],x=y?.match(/^(\s*)/);if(d===""&&x&&x[1].length>h&&y.trim().startsWith("- "))i[g.trim()]=n(h+2);else if(d===""&&x&&x[1].length>h&&y.trim().startsWith("[")){let p=[];for(;t<e.length;){const v=e[t].trim();if(p.push(v),t++,v.endsWith("]"))break}const w=p.join(" ").replace(/\s+/g," ");i[g.trim()]=s(w)}else if(x&&x[1].length>h){const p=r(h+2);i[g.trim()]=Object.keys(p).length?p:s(d)}else i[g.trim()]=s(d)}else if(f.trim().startsWith("- ")){c||(c=[]);let g=f.slice(f.indexOf("- ")+2);if(g.includes(":")){const[u,...d]=g.split(":"),y=d.join(":").trim(),x={};x[u.trim()]=s(y),t++;const p=r(h+2);Object.assign(x,p),c.push(x)}else c.push(s(g.trim())),t++}else t++}return c&&c.length>0?c:c&&c.length===0&&a===0?[]:i}function n(a=0){const i=[];for(;t<e.length;){let c=e[t];if(!c.trim()||c.trim().startsWith("#")){t++;continue}const f=c.match(/^(\s*)/)[1].length;if(f<a)break;if(c.trim().startsWith("- ")){let h=c.slice(c.indexOf("- ")+2);if(h.includes(":")){const[g,...u]=h.split(":"),d=u.join(":").trim(),y={};y[g.trim()]=s(d),t++;const x=r(f+2);Object.assign(y,x),i.push(y)}else i.push(s(h.trim())),t++}else break}return i}function s(a){if(a==="true")return!0;if(a==="false")return!1;if(/^-?\d+(\.\d+)?$/.test(a))return Number(a);if(a.startsWith("[")&&a.endsWith("]"))return a.slice(1,-1).split(",").map(i=>i.replace(/^[\s'"]+|[\s'",]+$/g,"")).filter(i=>i.length>0);if(a==="null")return null;if(a!=="")return a}return r(0)}function oe({rawContent:l}){const e=l.match(/^---\s*\n([\s\S]*?)\n---\s*\n?/);let t={};if(e){const r=Q({rawContent:e[1]});t=Array.isArray(r)?r[0]:r}return t}function ie({rawContent:l}){return JSON.parse(typeof l=="string"?l:new TextDecoder().decode(l))}const G={markdown:({rawContent:l})=>{const e=l instanceof Uint8Array?new TextDecoder().decode(l):l;return oe({rawContent:e})},yaml:({rawContent:l})=>{const e=l instanceof Uint8Array?new TextDecoder().decode(l):l;return Q({rawContent:e})},json:({rawContent:l})=>{const e=l instanceof Uint8Array?new TextDecoder().decode(l):l;return ie({rawContent:e})}};function ae(l,e){G[l]=e}async function z(l,e){let t;e.rawContent instanceof Uint8Array?t=new TextDecoder().decode(e.rawContent):t=e.rawContent;const r=G[l];if(!r)throw new Error(`No parser registered for type: ${l}`);return r({rawContent:t})}class H{constructor(e,t,r){this.repository=e,this.resolver=t,this.validator=r,this.cache=new Y}async loadBySourceName(e){const t=this.resolver.resolveOne(e),r=await this.repository.listFiles(t.pattern),n=[];for(const o of r)n.push(await this.load(o,t));return Array.isArray(n)&&Array.isArray(n[0])?n.flat():n}async load(e,t){let r;try{r=await this.repository.readFile(e)}catch{throw new Error(`Target Source [${e}] is not found.`)}const n=await z(t.type,{rawContent:r});let s=[];return Array.isArray(n)?(n.map(o=>this.validator.validate(o,t.schema,t.name)),s=n.flat()):(n.slug=L.getSlugFromPath(t.pattern,e),this.validator.validate(n,t.schema,t.name),s=n),s}async loadBySlug(e,t){const r=this.resolver.resolveOne(e);if(!r)throw new Error(`Unknown source: ${e}`);let n;r.pattern.includes("*")?n=L.getSourcePathsBySlugs(r.pattern,[t])[0]:n=r.pattern;try{const{parsed:s,raw:o}=await this.parseFile(n,r);if(Array.isArray(s)){const a=s.find(i=>i&&i.slug===t);if(!a)throw new Error(`Slug '${t}' not found in file: ${n}`);return this.validator.validate(a,r.schema,r.name),a.raw=o,a}else return this.validator.validate(s,r.schema,r.name),s.raw=o,s}catch(s){throw new Error(`Failed to loadBySlug: ${n} — ${s}`)}}async loadBySlugs(e,t){const r=[...new Set(t)];return Promise.all(r.map(n=>this.loadBySlug(e,n)))}async parseFile(e,t){if(await this.cache.has(e)){const s=await this.cache.get(e);if(s)return s}let r=await this.repository.readFile(e),n=await z(t.type,{rawContent:r});if(t.pattern.includes("*")&&!Array.isArray(n)&&typeof n=="object"&&n!==null){const s=L.getSlugFromPath(t.pattern,e),o=n;if(!o.slug)o.slug=s;else if(!s.includes(String(o.slug)))throw new Error(`Slug mismatch: expected "${s}", got "${o.slug}" in ${e}`);n=o}return await this.cache.set(e,{parsed:n,raw:r}),{parsed:n,raw:r}}}class ce{constructor(e,t,r,n,s){this.sourceName=e,this.loader=t,this.indexer=r,this.resolver=n,this.logger=s,this.joins=[],this.filters=[],this._orderByKey="slug",this._orderByDirection="asc",this._cursorDirection="after",this._pageSize=20}join(e){return this.joins=[...this.joins,e],this}where(e,t,r){return this.filters.push({field:e,op:t,value:r}),this}async find(e){const t=this.resolver.resolveOne(this.sourceName),r=this.joins.length>0;let n=await this.loader.loadBySlug(this.sourceName,e);return r&&(n=(await this.applyJoins([n],t))[0]),n}orderBy(e,t="asc"){return this._orderByKey=e,this._orderByDirection=t,this}cursor(e,t="after"){return this._cursorValue=e,this._cursorDirection=t,this}pageSize(e){return this._pageSize=e,this}async exec(){const e=this.resolver.resolveOne(this.sourceName),t=this.joins.length>0,{page:r,pageInfo:n}=await this.compose(),s=r.flatMap(a=>Object.keys(a.ref));let o=await this.loader.loadBySlugs(this.sourceName,s);return t&&(o=await this.applyJoins(o,e)),{data:o,pageInfo:n}}async peek(){return await this.compose()}async compose(){const e=this.resolver.resolveOne(this.sourceName),t=this.extractIndexFilters(e),r=String(this._orderByKey),n={page:[],pageInfo:{hasNextPage:!1,hasPreviousPage:!1,startCursor:void 0,endCursor:void 0}};let s=await this.getMatchedIndexes(this.sourceName,t,e),o,a;const i=c=>{const f=Object.keys(c.ref).length,h=Object.keys(c.ref)[f-1],g=Object.values(c.ref)[f-1][r];return ne({order:{[r]:g[0]},slug:h})};if(s.length){const c=this._cursorValue?N(this._cursorValue):void 0,f=this.getStartIdx(s,c);o=re(s,f,this._pageSize,this._cursorDirection),a=se(o,this._pageSize,f,s.length,this._cursorDirection,i)}else if(!s.length&&!t.length){if(!e.indexes[r])throw new Error(`[${this.sourceName}] needs index: ${r}`);const c=e.indexes[r].dir,f=this._orderByDirection==="desc",h=this._cursorDirection==="after";let g,u;if(h?o=await Array.fromAsync(this.indexer.readForwardPrefixIndexLines(c,this._pageSize+1,this._cursorValue,r,f)):o=(await Array.fromAsync(this.indexer.readBackwardPrefixIndexLines(c,this._pageSize+1,this._cursorValue,r,f))).reverse(),!o.length)return n;g=h?!!this._cursorValue:o.length>this._pageSize,u=h?o.length>this._pageSize:!!this._cursorValue,o=o.slice(0,this._pageSize),a={hasPreviousPage:g,hasNextPage:u,startCursor:i(o[0]),endCursor:i(o[o.length-1])}}else return n;return{page:o,pageInfo:a}}getStartIdx(e,t){if(!t)return 0;const r=String(this._orderByKey);return e.findIndex(n=>{for(const[s,o]of Object.entries(n.ref)){let a=s===t.slug;if(r&&t.order[r]){const i=o[r]?.[0];a=a&&i===t.order[r]}return a}return!1})}extractIndexFilters(e){const t=new Set(["slug",...Object.keys(e.indexes??{})]),r=this.filters.filter(s=>t.has(s.field)),n=this.filters.filter(s=>!t.has(s.field));if(n.length>0)throw new Error(`[${this.sourceName}] needs index: ${JSON.stringify(n)}`);return r}async applyJoins(e,t){for(const r of this.joins){const n=t.relations?.[r];if(!n)throw new Error(`Unknown relation: ${r}`);n.type==="hasOneThrough"||n.type==="hasManyThrough"?e=await this.applyThroughRelation(e,r,n):(n.type==="hasOne"||n.type==="hasMany"||n.type==="belongsTo"||n.type==="belongsToMany")&&(e=await this.applyDirectRelation(e,r,n))}return e}async applyDirectRelation(e,t,r){const n=r;let s=[];if(n.type==="belongsTo"||n.type==="belongsToMany"){const o=e.flatMap(i=>F(i,n.localKey)),a=await this.getMatchedIndexes(n.to,[{field:n.foreignKey,op:"in",value:o}],this.resolver.resolveOne(n.to))??[];s=await this.loader.loadBySlugs(n.to,a.map(i=>Object.keys(i.ref)).flat())}else{const o=e.flatMap(i=>F(i,n.localKey)),a=Array.from(new Set(o));s=await this.loader.loadBySlugs(n.to,a)}return e.map(o=>{if(n.type==="belongsTo"||n.type==="belongsToMany"){const a=F(o,n.localKey),i=s.filter(c=>{const f=F(c,n.foreignKey);return a.some(h=>f.includes(h))});return{...o,[t]:i}}else{const a=V(o,n,s);return{...o,[t]:n.type==="hasOne"?a??null:a??[]}}})}async applyThroughRelation(e,t,r){const n=e.flatMap(f=>F(f,r.sourceLocalKey)),s=await this.getMatchedIndexes(r.through,[{field:r.throughForeignKey,op:"in",value:n}],this.resolver.resolveOne(r.through))??[],o=await this.loader.loadBySlugs(r.through,s.map(f=>Object.keys(f.ref)).flat()),a=o.flatMap(f=>F(f,r.throughLocalKey)),i=await this.getMatchedIndexes(r.to,[{field:r.targetForeignKey,op:"in",value:a}],this.resolver.resolveOne(r.through))??[],c=await this.loader.loadBySlugs(r.to,i.map(f=>Object.keys(f.ref)).flat());return e.map(f=>{const h=W(f,r,o,c);return{...f,[t]:r.type==="hasOneThrough"?h??null:h??[]}})}async getMatchedIndexes(e,t,r,n=!0){let s=null;for(let a=0;a<t.length;a++){const i=t[a],{field:c,op:f,value:h}=i;let g=[];if(c==="slug"&&(f==="eq"||f==="in"&&Array.isArray(h)))g=q(h).map(d=>String(d)).map(d=>({v:d,vs:d,ref:{[d]:{slug:[d]}}}));else if(n&&s&&a>0){const d=r.indexes?.[c]?.depth??O.indexDepth;let y=[];for(const x of q(h)){const p=String(x),w=this.indexer.getPrefixIndexPath(p,d),v=s.filter(m=>{const S=Object.keys(m.ref)[0],b=m.ref[S]?.[c];return b?b.some(P=>f==="startsWith"?P.startsWith(w):P===w):!1});if(v.length)if(p.length<=d)y.push(...v);else{const m=await this.indexer.findIndexLines(e,c,p);if(!m)continue;y.push(...s.filter(S=>{const b=Object.keys(S.ref)[0];return m.some(P=>!!P.ref[b])}))}}if(g.push(...y),!g.length)return[]}else if(Object.keys(r.indexes??{}).length){if(f==="eq")g=await this.indexer.findIndexLines(e,c,String(h))??[];else if(f==="startsWith")g=await this.indexer.findIndexLines(e,c,String(h),(u,d)=>u.startsWith(d))??[];else if(f==="in"&&Array.isArray(h)){const u=new Set;for(const y of h)u.add(this.indexer.findIndexLines(e,c,String(y)));const d=(await Promise.all([...u])).flat();g.push(...d.filter(y=>!!y))}}n?s=g:s=[...s??[],...g]}const o=s??[];return o.sort((a,i)=>{const[,c]=Object.entries(a.ref)[0],[,f]=Object.entries(i.ref)[0],h=String(c[String(this._orderByKey)]),g=String(f[String(this._orderByKey)]),u=h==null||h==="",d=g==null||g==="";if(u||d)throw new Error("orderby need index");return this._orderByDirection==="desc"?g.localeCompare(h):h.localeCompare(g)}),o.length?o:[]}}function U(l,e,t="",r=null){r||(r=JSON.stringify(l));const n=e.type;if(!n)return;const s=Array.isArray(n)?n:[n],o=t||"value";if(l===null){if(!s.includes("null"))throw new Error(`Expected ${s.join(" or ")} at '${o}', got null, at: ${r}`);return}if(s.includes("array")){if(!Array.isArray(l))throw new Error(`Expected array at '${o}', got ${typeof l}, at: ${r}`);if(e.items)for(let c=0;c<l.length;c++)U(l[c],e.items,`${o}[${c}]`);return}if(s.includes("object")){if(typeof l!="object"||Array.isArray(l))throw new Error(`Expected object at '${o}', got ${typeof l}`);for(const c of e.required??[])if(!(c in l))throw new Error(`Missing required field: '${o}.${c}', at: ${r}`);for(const[c,f]of Object.entries(e.properties??{})){const h=l[c];h!==void 0&&U(h,f,`${o}.${c}`,r)}return}const a=typeof l;let i=!1;for(const c of s){switch(c){case"string":a==="string"&&(i=!0);break;case"number":a==="number"&&(i=!0);break;case"integer":a==="number"&&Number.isInteger(l)&&(i=!0);break;case"boolean":a==="boolean"&&(i=!0);break;case"date":(typeof l=="string"||typeof l=="object")&&!isNaN(Date.parse(l))&&(i=!0);break}if(i)break}if(!i)throw new Error(`Expected ${s.join(" or ")} at '${o}', got ${a}, at: ${r}`)}const le={validate(l,e,t){U(l,e,t)}};class fe{constructor(e="info"){this.currentLevel=e,this.levelOrder={debug:1,info:2,warn:3,error:4,silent:5}}setLevel(e){this.currentLevel=e}shouldLog(e){return this.levelOrder[e]>=this.levelOrder[this.currentLevel]}debug(...e){this.shouldLog("debug")&&console.debug("[staticql][debug]",...e)}info(...e){this.shouldLog("info")&&console.info("[staticql]",...e)}warn(...e){this.shouldLog("warn")&&console.warn("[staticql][warn]",...e)}error(...e){this.shouldLog("error")&&console.error("[staticql][error]",...e)}}class he{constructor(e,t,r,n={}){this.config=e,this.repository=t,this.sourceConfigResolver=r,this.options=n,this.validator=this.options.validator??le,this.logger=this.options.logger??new fe("info")}from(e){const t=new H(this.repository,this.sourceConfigResolver,this.validator),r=new O(t,this.repository,this.sourceConfigResolver,this.logger);return new ce(e,t,r,this.sourceConfigResolver,this.logger)}async saveIndexes(e){await this.getIndexer(e).save()}getConfig(){return this.config}getIndexer(e){const t=new H(this.repository,this.sourceConfigResolver,this.validator);return new O(t,this.repository,this.sourceConfigResolver,this.logger,e)}}class ue{constructor(e,t,r){this.defaultRepository=e,this.sourceRepositories=t,this.writeRepository=r??e}setResolver(e){if(this.resolver=e,this.defaultRepository&&typeof this.defaultRepository.setResolver=="function"&&this.defaultRepository.setResolver(e),this.sourceRepositories)for(const t of Object.values(this.sourceRepositories))t&&typeof t.setResolver=="function"&&t.setResolver(e);this.writeRepository&&typeof this.writeRepository.setResolver=="function"&&this.writeRepository.setResolver(e)}getReadRepositoryForPattern(e){if(this.resolver&&this.sourceRepositories){for(const[t,r]of Object.entries(this.resolver.resolveAll()))if(r.pattern===e){const n=this.sourceRepositories[t];if(n)return n}}if(this.defaultRepository)return this.defaultRepository;throw new Error(`MultiRepository: no repository found for pattern: ${e}`)}getReadRepositoryForPath(e){if(this.resolver&&this.sourceRepositories){for(const{name:t,pattern:r}of this.resolver.resolveAll())if(L.patternTest(r,e)){const n=this.sourceRepositories[t];if(n)return n;break}}if(this.defaultRepository)return this.defaultRepository;throw new Error(`MultiRepository: no repository found for path: ${e}`)}async listFiles(e){return this.getReadRepositoryForPattern(e).listFiles(e)}async readFile(e){return this.getReadRepositoryForPath(e).readFile(e)}async openFileStream(e){return this.getReadRepositoryForPath(e).openFileStream(e)}async exists(e){return this.getReadRepositoryForPath(e).exists(e)}async writeFile(e,t){return this.writeRepository.writeFile(e,t)}async removeFile(e){return this.writeRepository.removeFile(e)}async removeDir(e){return this.writeRepository.removeDir(e)}}function we(l){return({repository:e,defaultRepository:t,sourceRepositories:r,writeRepository:n,options:s={}})=>{if(s.parsers)for(const[i,c]of Object.entries(s.parsers))ae(i,c);const o=new L(l.sources);let a;if(t||r||n)a=new ue(t??e,r,n??t??e);else{if(!e)throw new Error("StaticQL requires a repository instance");a=e}return"setResolver"in a&&typeof a.setResolver=="function"&&a.setResolver(o),new he(l,a,o,s)}}class me{constructor(e="/"){this.baseUrl=e.replace(/\/+$/,"")+"/"}setResolver(e){this.resolver=e}async readFile(e){const t=this.baseUrl+e.replace(/^\/+/,""),r=await fetch(t);if(!r.ok)throw new Error(`Failed to fetch: ${t}`);return await r.text()}async exists(e){const t=this.baseUrl+e.replace(/^\/+/,"");return(await fetch(t,{method:"HEAD"})).ok}async listFiles(e){const r=(this.resolver?.resolveAll()??[]).find(i=>e.startsWith(i.pattern));if(!r)return[];const n=`index/${r.name}.slug`,o=(await this.readAllIndexesRemote(n)).map(i=>i.v).filter(Boolean);let a;return e.includes("*")?a=L.getSourcePathsBySlugs(e,o):a=o.map(i=>r.pattern.replace("*",i)),a}async writeFile(e,t){throw new Error("writeFile is not supported in browser environment")}async removeFile(e){throw new Error("removeFile is not supported in browser environment")}async removeDir(e){throw new Error("removeFile is not supported in browser environment")}async fetchIndexFile(e){const t=e.startsWith("/")?this.baseUrl+e.replace(/^\/+/,""):this.baseUrl+e,r=await fetch(t);return r.ok?await r.json():[]}async openFileStream(e){const t=await fetch(`${this.baseUrl}${e}`);if(!t.ok)throw new Error(`Failed to fetch ${e}`);return t.body}async readAllIndexesRemote(e){const t=[];try{const r=R(this.baseUrl,e),n=await fetch(r);if(n.ok){const s=await n.text(),o=this.flatPrefixIndexLine(s.split(`
`).map(a=>a.trim()).filter(Boolean).map(a=>JSON.parse(a)));t.push(...o)}}catch{}try{const r=M(this.baseUrl,e),n=await fetch(r);if(n.ok){const s=await n.text(),o=te(s);for(const a of o){const i=j(e,a),c=await this.readAllIndexesRemote(i);t.push(...c)}}}catch{}return t}flatPrefixIndexLine(e){const t=new Set,r=[];for(const n of e)for(const[s,o]of Object.entries(n.ref))t.has(s)||(t.add(s),r.push({v:n.v,vs:n.vs,ref:{[s]:o}}));return r}}export{me as F,xe as I,ye as L,we as d};
